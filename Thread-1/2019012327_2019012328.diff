diff --git a/Thread-1/.gitignore b/Thread-1/.gitignore
new file mode 100644
index 0000000..772258b
--- /dev/null
+++ b/Thread-1/.gitignore
@@ -0,0 +1,6 @@
+bazel-bin
+bazel-out
+bazel-testlogs
+bazel-Thread-1
+
+*.txt
diff --git a/Thread-1/.vscode/settings.json b/Thread-1/.vscode/settings.json
new file mode 100644
index 0000000..431dd9e
--- /dev/null
+++ b/Thread-1/.vscode/settings.json
@@ -0,0 +1,78 @@
+{
+    "files.associations": {
+        "array": "cpp",
+        "vector": "cpp",
+        "xstring": "cpp",
+        "xutility": "cpp",
+        "cmath": "cpp",
+        "algorithm": "cpp",
+        "atomic": "cpp",
+        "bit": "cpp",
+        "cctype": "cpp",
+        "charconv": "cpp",
+        "chrono": "cpp",
+        "clocale": "cpp",
+        "compare": "cpp",
+        "concepts": "cpp",
+        "cstddef": "cpp",
+        "cstdint": "cpp",
+        "cstdio": "cpp",
+        "cstdlib": "cpp",
+        "cstring": "cpp",
+        "ctime": "cpp",
+        "cwchar": "cpp",
+        "exception": "cpp",
+        "format": "cpp",
+        "forward_list": "cpp",
+        "fstream": "cpp",
+        "initializer_list": "cpp",
+        "iomanip": "cpp",
+        "ios": "cpp",
+        "iosfwd": "cpp",
+        "iostream": "cpp",
+        "istream": "cpp",
+        "iterator": "cpp",
+        "limits": "cpp",
+        "locale": "cpp",
+        "map": "cpp",
+        "memory": "cpp",
+        "mutex": "cpp",
+        "new": "cpp",
+        "optional": "cpp",
+        "ostream": "cpp",
+        "ratio": "cpp",
+        "sstream": "cpp",
+        "stdexcept": "cpp",
+        "stop_token": "cpp",
+        "streambuf": "cpp",
+        "string": "cpp",
+        "system_error": "cpp",
+        "thread": "cpp",
+        "tuple": "cpp",
+        "type_traits": "cpp",
+        "typeinfo": "cpp",
+        "utility": "cpp",
+        "xfacet": "cpp",
+        "xiosbase": "cpp",
+        "xlocale": "cpp",
+        "xlocbuf": "cpp",
+        "xlocinfo": "cpp",
+        "xlocmes": "cpp",
+        "xlocmon": "cpp",
+        "xlocnum": "cpp",
+        "xloctime": "cpp",
+        "xmemory": "cpp",
+        "xstddef": "cpp",
+        "xtr1common": "cpp",
+        "xtree": "cpp",
+        "cinttypes": "cpp",
+        "condition_variable": "cpp",
+        "functional": "cpp",
+        "list": "cpp",
+        "regex": "cpp",
+        "set": "cpp",
+        "unordered_map": "cpp",
+        "unordered_set": "cpp",
+        "xhash": "cpp"
+    }
+}
\ No newline at end of file
diff --git a/Thread-1/BUILD b/Thread-1/BUILD
index 28f4114..94be188 100644
--- a/Thread-1/BUILD
+++ b/Thread-1/BUILD
@@ -1,5 +1,21 @@
 ##load("@rules_cc//cc:defs.bzl", "cc_test")  #load the test target
 
+cc_binary(
+    name = "q0_my",
+    srcs = [
+        "q0_my.cc"
+            ],
+    deps = [
+        "//lib:instruction_lib",
+        "//lib:utils_lib",
+        "//lib:server_lib"
+    ],
+    copts = [
+        "-std=c++11",
+    ],
+    data = glob(["data/q0*"]),
+)
+
 cc_binary(
     name = "q0",
     srcs = [
@@ -29,6 +45,16 @@ cc_binary(
     srcs = [
         "q1.cc"
             ],
+    deps = [
+        "//lib:instruction_lib",
+        "//lib:utils_lib",
+        "//lib:server_lib"
+    ],
+    copts = [
+        "-std=c++11",
+    ],
+    linkopts = ["-lpthread"],
+    data = glob(["data/q1*"]),
 )
 
 cc_binary(
@@ -36,6 +62,16 @@ cc_binary(
     srcs = [
         "q2.cc"
             ],
+    deps = [
+        "//lib:instruction_lib",
+        "//lib:utils_lib",
+        "//lib:server_lib"
+    ],
+    copts = [
+        "-std=c++11",
+    ],
+    linkopts = ["-lpthread"],
+    data = glob(["data/q2*"]),
 )
 
 cc_binary(
@@ -43,6 +79,33 @@ cc_binary(
     srcs = [
         "q3.cc"
             ],
+    deps = [
+        "//lib:instruction_lib",
+        "//lib:utils_lib",
+        "//lib:server_lib"
+    ],
+    copts = [
+        "-std=c++11",
+    ],
+    linkopts = ["-lpthread"],
+    data = glob(["data/q3*"]),
+)
+
+cc_binary(
+    name = "q4",
+    srcs = [
+        "q4.cc"
+            ],
+    deps = [
+        "//lib:instruction_lib",
+        "//lib:utils_lib",
+        "//lib:server_lib"
+    ],
+    copts = [
+        "-std=c++11",
+    ],
+    linkopts = ["-lpthread"],
+    data = glob(["data/q4*"]),
 )
 
 cc_test(
diff --git a/Thread-1/README.md b/Thread-1/README.md
index 52f2b01..8fd28b4 100644
--- a/Thread-1/README.md
+++ b/Thread-1/README.md
@@ -1,28 +1,16 @@
 # Project 1: Multi-thread Programming
 
-This project uses a (oversimplified) machine learning inference system to allow
-you to put some basic OS concepts into practice and learn how system-level
-optimizations help improve performance. 
-
-Suppose you are hired by a company to improve the efficiency of the optimization
-process of a recommender system. This recommender system represents the users
-and items (i.e. goods offered by the E-commerce platform) as vectors, and uses
-these embedding vectors to calculate the semantic similarities between
-user-user, user-item and item-item pairs. Since you are a system expert, the
-company hopes you can improve the efficiency of the embedding maintenance of
-the recommender system.
+This project uses a (oversimplified) machine learning inference system to allow you to put some basic OS concepts into practice and learn how system-level optimizations help improve performance.
+
+Suppose you are hired by a company to improve the efficiency of the optimization  process of a recommender system. This recommender system represents the users and items (i.e. goods offered by the E-commerce platform) as vectors, and uses these embedding vectors to calculate the semantic similarities between user-user, user-item and item-item pairs. Since you are a system expert, the company hopes you can improve the efficiency of the embedding maintenance of the recommender system.
 
 ## Introduction
 
-The AI algorithm engineers of the company explain the basics of the setup to
-you, as follows.
+The AI algorithm engineers of the company explain the basics of the setup to you, as follows.
 
 ### Embedding Vectors
 
-Embedding vectors represent the entities (either a user or an item). These
-vectors are stored as rows in an embedding matrix. These embedding vectors have
-a property that the product of two embedding vectors (maybe after some
-processing) indicates the similarity of the two corresponding entities.
+Embedding vectors represent the entities (either a user or an item). These vectors are stored as rows in an embedding matrix. These embedding vectors have a property that the product of two embedding vectors (maybe after some processing) indicates the similarity of the two corresponding entities.
 
 ```bash
 ...
@@ -39,23 +27,13 @@ Three important operations on the embedding vectors are
 2. Updating the vectors after observing user activities (`update`).
 3. Recommend an item to a user from a list of items.
 
-The embedding initialization is difficult, as there is few information about a
-new entity. For a new user, a simple method is to randomly initialize the
-embedding and run some cold start procedure (e.g. recommending some popular
-item) to probe the user's interest. For a new item, we may expose them to highly
-active users.
+The embedding initialization is difficult, as there is few information about a new entity. For a new user, a simple method is to randomly initialize the embedding and run some cold start procedure (e.g. recommending some popular item) to probe the user's interest. For a new item, we may expose them to highly active users.
 
-After observing some user activities, we gather information about the users'
-interest and items' popularity. To encode this information into the embeddings,
-we need to update the embedding vectors with some optimization method (e.g.
-gradient descent) where we pull in the distance between similar entities and
-push away those dissimilar entities.
+After observing some user activities, we gather information about the users' interest and items' popularity. To encode this information into the embeddings, we need to update the embedding vectors with some optimization method (e.g. gradient descent) where we pull in the distance between similar entities and push away those dissimilar entities.
 
 ## Embedding Holder
 
-In this project, we utilize `EmbeddingHolder` (a collection of embeddings) as the database to store 
-and update the company's data. Initially, we read data from `*.in` to create two basic `EmbeddingHolder` for **users**
-and **items** respectively; our task is to update this database according to the incoming `Instruction`s.
+In this project, we utilize `EmbeddingHolder` (a collection of embeddings) as the database to store and update the company's data. Initially, we read data from `*.in` to create two basic `EmbeddingHolder` for **users** and **items** respectively; our task is to update this database according to the incoming `Instruction`s.
 
 ### Codebase
 
@@ -88,35 +66,21 @@ The project directory looks like this:
 
 ```
 
-The source files in `lib/` implements the basic interfaces of the system. The
-`lib/embedding.h` contains the main interface of the embedding matrix data
-holder. The mentioned operations on the embedding matrix are implemented in
-`lib/model.h`. `Instruction` is in `lib/instruction.h`. The utilities are in `lib/utils.h`.
-You find these files belongs to the AI team and you should not 
-modify them, and do your optimization all from the system level. 
+The source files in `lib/` implements the basic interfaces of the system. The `lib/embedding.h` contains the main interface of the embedding matrix data holder. The mentioned operations on the embedding matrix are implemented in `lib/model.h`. `Instruction` is in `lib/instruction.h`. The utilities are in `lib/utils.h`. You find these files belongs to the AI team and you should not modify them, and do your optimization all from the system level.
 
-The entrance of the program is in `q*.cc`.
-You can modify everything in this project, except those tests in `lib`.
-You should ensure that after your modification, it still passes the tests in `lib`.
+The entrance of the program is in `q*.cc`. You can modify everything in this project, except those tests in `lib`. You should ensure that after your modification, it still passes the tests in `lib`.
 
-The project builds with the bazel build system, as we discussed in the
-discussion session. You should install bazel following the online documents and
-read the BUILD and WORKSPACE files carefully to understand the dependencies and
-code structure. 
+The project builds with the bazel build system, as we discussed in the discussion session. You should install bazel following the online documents and read the BUILD and WORKSPACE files carefully to understand the dependencies and code structure.
 
 ### Unit testing
 
-Writing unit tests is an essential way to build and optimize system programs
-and thus we would require that you include unit tests for all major functions
-you write for your code. 
+Writing unit tests is an essential way to build and optimize system programs and thus we would require that you include unit tests for all major functions you write for your code.
 
-We have provided test cases in the libraries for you as examples. Please do not
-modify these unit tests.  You can modify library code, and add your own test cases
-to the library test, but make sure that after your modification, our provided test cases still pass.
+We have provided test cases in the libraries for you as examples. Please do not modify these unit tests.  You can modify library code, and add your own test cases to the library test, but make sure that after your modification, our provided test cases still pass.
 
 ### Format Checking
 
- In this project we test the standard output stream for final grading, so make sure that you output the correct answer as you expect. We provide a format checking script in `format.cc`. You can modify it to test all output results of your submission. Run the format checking script after building it like this:
+In this project we test the standard output stream for final grading, so make sure that you output the correct answer as you expect. We provide a format checking script in `format.cc`. You can modify it to test all output results of your submission. Run the format checking script after building it like this:
 
 ```bash
 bazel-bin/q0 |grep [OUTPUT] > format.out && bazel-bin/format
@@ -124,25 +88,13 @@ bazel-bin/q0 |grep [OUTPUT] > format.out && bazel-bin/format
 
 ### Instruction Files
 
-The workload of the company comes as `Instruction`s with `order` and `payload`
-fields. Both fields are integers. In this project, the `Instruction.order` is
-either 0, 1 or 2, indicating the task of "init", "update" or "recommend". The workflow
-of different task types are different as described bellow.
-
-- For **“init”**, you should first create a new embedding. The payload is a
-  list of existing embedding indeces in the input matrix (`EmbeddingHolder`) that
-  are used for cold  start (downstream applications may use them for interest
-  probing). You should add this new  embedding into the `EmbeddingHolder` using
-  `append`. Then you need to call `cold_start`  for each of the embedding
-  indeces. Note that after `cold_start`, **only user embeddings are updated**
-  (see `q0.cc` for example).
-
-- For **“update”**, the payload is `[user_idx, item_idx, label, (iter_idx)]`. You should invoke
-  the `calc_gradient` on these two embedding vectors from `lib/model.h` and then
-  call `update_embedding` from `lib/embedding.h` **on both the user and the items**
-  (see`project/embedding.cc:run_q0` for example). The `iter_idx` indicates the
-  epoch number of current update, see Task-3 for information.
-- For **"recommend"**, the the payload is `[user_idx, iter_idx, item_idx1, item_idx2, item_idx3, item_idx4, ...]`. You should invoke the `recommend` on these embedding vectors from `lib/model.h` and then output the result. 
+The workload of the company comes as `Instruction`s with `order` and `payload` fields. Both fields are integers. In this project, the `Instruction.order` is either 0, 1 or 2, indicating the task of "init", "update" or "recommend". The workflow of different task types are different as described bellow.
+
+- For **“init”**, you should first create a new embedding. The payload is a list of existing embedding indices in the input matrix (`EmbeddingHolder`) that are used for cold  start (downstream applications may use them for interest probing). You should add this new  embedding into the `EmbeddingHolder` using `append`. Then you need to call `cold_start`  for each of the embedding indices. Note that after `cold_start`, **only user embeddings are updated** (see `q0.cc` for example).
+
+- For **“update”**, the payload is `[user_idx, item_idx, label, (iter_idx)]`. You should invoke the `calc_gradient` on these two embedding vectors from `lib/model.h` and then call `update_embedding` from `lib/embedding.h` **on both the user and the items** (see`project/embedding.cc:run_q0` for example). The `iter_idx` indicates the epoch number of current update, see Task-3 for information.
+
+- For **"recommend"**, the the payload is `[user_idx, iter_idx, item_idx1, item_idx2, item_idx3, item_idx4, ...]`. You should invoke the `recommend` on these embedding vectors from `lib/model.h` and then output the result.
 
 Note that NO provided functions are thread safe on their own.
 
@@ -150,8 +102,7 @@ Note that NO provided functions are thread safe on their own.
 
 For the following tasks, you should minimize duplicate code.  If there are code sharing among the following tasks, you should extract as much shared code as possible into separate `.h` and `.cc` library files, but not put everything into a single `.cc` file.  You should create your own `_test.cc` file for your library code.  20% of this project grade are reserved for good coding style (including the completeness of your own test cases).  
 
-We recommend you to use the standard C++11 Threading to implement multi-threading.  However, please feel free to use any other
-C++ threading library (such as `pthread`, or Intel's TBB to do the following task).  If you need external libraries, please include them in the `WORKSPACE` file and make them to install and build automatically.  The TAs are not obliged to manually install any libraries on the grading machine. 
+We recommend you to use the standard C++11 Threading to implement multi-threading.  However, please feel free to use any other C++ threading library (such as `pthread`, or Intel's TBB to do the following task).  If you need external libraries, please include them in the `WORKSPACE` file and make them to install and build automatically.  The TAs are not obliged to manually install any libraries on the grading machine.
 
 ## Submission instructions
 
@@ -165,55 +116,37 @@ To test whether your `.diff` works, clone a new repo and call `git apply ${STUDE
 
 ## Task-0: Play with bazel build, the code and sanity check
 
-In this task, you need to understand the project structure, read the `q0.cc` code and 
-the `project/BUILD` files, install bazel, build and run the provided sample program and tests. 
-This task is not included for grading.  Just provided as an example for you to read.  If you need more information
-on the Bazel build system, please refer to
-https://docs.bazel.build/versions/main/tutorial/cpp.html
-
+In this task, you need to understand the project structure, read the `q0.cc` code and the `project/BUILD` files, install bazel, build and run the provided sample program and tests. This task is not included for grading.  Just provided as an example for you to read.  If you need more information on the Bazel build system, please refer to [https://docs.bazel.build/versions/main/tutorial/cpp.html]()
 
-> **_NOTE:_** You can take this task's code as an example and benchmark for following tasks, 
-but do not copy and paste this unoptimized code! Otherwise you will get penalized. Task-0 is not included in the final grading.
+> **_NOTE:_** You can take this task's code as an example and benchmark for following tasks, but do not copy and paste this unoptimized code! Otherwise you will get penalized. Task-0 is not included in the final grading.
 
 > **_NOTE:_** Your code is not required to output exactly the same answer as `q0.cc`. You just need to guarantee your code is thread-safe.
 
 ## Task-1: Supporting concurrent users
 
-At the beginning, the recommender system is new and has very few items or users.
-Fortunately, the company attracts more and more users.  Thus, we need to modify the system
-so that when multiple users come in at the same time, and send `Instruction`s concurrently
-the system could behave correctly and efficiently. 
+At the beginning, the recommender system is new and has very few items or users. Fortunately, the company attracts more and more users.  Thus, we need to modify the system so that when multiple users come in at the same time, and send `Instruction`s concurrently the system could behave correctly and efficiently.
 
 **ToDo:**
 
-In this task, your job is to process an `Instruction` set of "init" and "update". Considering that 
-`cal_gradient`  is time-consuming (10s of seconds running time, mostly waiting for I/O), 
-you should think of handling multiple `Instruction`s concurrently. Design 
-a synchronization mechanism using locks to guarantee that your codes are thread-safe.  Output your final 
-`EmbeddingHolder` of **1) users and 2) items** using the provided `EmbeddingHolder::write_to_stdout()`.
+In this task, your job is to process an `Instruction` set of "init" and "update". Considering that `cal_gradient`  is time-consuming (10s of seconds running time, mostly waiting for I/O), you should think of handling multiple `Instruction`s concurrently. Design a synchronization mechanism using locks to guarantee that your codes are thread-safe.  Output your final `EmbeddingHolder` of **1) users and 2) items** using the provided `EmbeddingHolder::write_to_stdout()`.
 
-Again, note that NO provided functions are thread safe on their own. Feel free to modify these functions
-in the `lib/` directory, but do not modify existing test cases there (you can add your own test cases).
+Again, note that NO provided functions are thread safe on their own. Feel free to modify these functions in the `lib/` directory, but do not modify existing test cases there (you can add your own test cases).
 
 **Grading:**
 
-You will be graded by both the correctness and efficiency of your calculation 
-under heavy and arbitrary mixtures of incoming `Instruction`s.
+You will be graded by both the correctness and efficiency of your calculation under heavy and arbitrary mixtures of incoming `Instruction`s.
 
-> **_NOTE:_** In this task, a single `Instruction` only runs in a single thread (i.e. no internal parallelism within an `Instruction`). 
+> **_NOTE:_** In this task, a single `Instruction` only runs in a single thread (i.e. no internal parallelism within an `Instruction`).
 
 > **_NOTE:_** The correctness means thread-safety. We allow any order of updates, as long as it is thread-safe.
 
 ## Task-2: Accelerate "Init" task through concurrency
 
-Now the engineers find that it is still too slow to conduct each "init" task, as each of the task need to read multiple 
-embeddings to perform the init.  
-They hope to read and use these embeddings concurrently so shorten the time required to call a single "init".
-We can further speed up the process by building an internally-concurrent "init" function.
+Now the engineers find that it is still too slow to conduct each "init" task, as each of the task need to read multiple embeddings to perform the init. They hope to read and use these embeddings concurrently so shorten the time required to call a single "init". We can further speed up the process by building an internally-concurrent "init" function.
 
 **ToDo:**
 
-In this task, your job is to process an `Instruction` set of "init" and "update". You can start with your codes in Task-1. Try to conduct multiple `cold_start`  in parallel and update the newly initialized embedding collectively without violating **thread-safety**.  Output your final `EmbeddingHolder` of **1) users and 2) items** using the provided `EmbeddingHolder::write_to_stdout()` function.  Note that you still need to support multiple concurrent users. 
+In this task, your job is to process an `Instruction` set of "init" and "update". You can start with your codes in Task-1. Try to conduct multiple `cold_start`  in parallel and update the newly initialized embedding collectively without violating **thread-safety**.  Output your final `EmbeddingHolder` of **1) users and 2) items** using the provided `EmbeddingHolder::write_to_stdout()` function.  Note that you still need to support multiple concurrent users.
 
 **Grading:**
 
@@ -221,11 +154,7 @@ You will be graded by the correctness and efficiency of your calculation.
 
 ## Task-3: Supporting incremental embedding updates
 
-Now the recommender system has many users and items. Everyday, the system
-observes user activities and use them to update the embedding matrix for better
-recommendation performance. In this task, you will need to implement the
-updating process of the embedding matrix. The algorithm engineers of the company come up with a "genius" optimization
-algorithm. This algorithm requires the optimizer to update the embeddings iteratively, and they call each iteration an *epoch*. This innovative epoch-based optimization differs from existing methods in that the calculation of later epochs depends on the results of earlier epochs. In this task, your job is to support this epoch-based update.
+Now the recommender system has many users and items. Everyday, the system observes user activities and use them to update the embedding matrix for better recommendation performance. In this task, you will need to implement the updating process of the embedding matrix. The algorithm engineers of the company come up with a "genius" optimization algorithm. This algorithm requires the optimizer to update the embeddings iteratively, and they call each iteration an *epoch*. This innovative epoch-based optimization differs from existing methods in that the calculation of later epochs depends on the results of earlier epochs. In this task, your job is to support this epoch-based update.
 
 **ToDo:**
 
@@ -237,12 +166,7 @@ You will be graded by the correctness and efficiency of your calculation.
 
 ## Task-4: Doing recommendation while updating the embedding
 
-Except the maintenance of the recommender system, the company also needs  to generate recommendations for each user using the 
-existing database. The recommendation should depend on the current version of data and not disturb the maintenance of the 
-recommender system.  Note that when an embedding update is going on, you can not at the same time read the embedding, as the 
-embedding update is not an atomic operation.  As the embedding update can take a long time, and can be quite frequent, 
-you need to figure out a way to allow recommendation to execute without getting blocked by the updates, and at the same time
-allowing the update to happen, and being able to use some quite recent updated embedding values for recommendation.  
+Except the maintenance of the recommender system, the company also needs  to generate recommendations for each user using the existing database. The recommendation should depend on the current version of data and not disturb the maintenance of the recommender system.  Note that when an embedding update is going on, you can not at the same time read the embedding, as the embedding update is not an atomic operation.  As the embedding update can take a long time, and can be quite frequent, you need to figure out a way to allow recommendation to execute without getting blocked by the updates, and at the same time allowing the update to happen, and being able to use some quite recent updated embedding values for recommendation.  
 
 **ToDo:**
 
diff --git a/Thread-1/README.pdf b/Thread-1/README.pdf
new file mode 100644
index 0000000..35cb1d9
diff --git a/Thread-1/lib/BUILD b/Thread-1/lib/BUILD
index 07eb930..7fca563 100644
--- a/Thread-1/lib/BUILD
+++ b/Thread-1/lib/BUILD
@@ -1,5 +1,35 @@
 ##load("@rules_cc//cc:defs.bzl", "cc_test")  #load the test target
 
+cc_library(
+    name = "server_lib",
+    srcs = [
+        "server.cc",
+        ],
+    hdrs = [
+        "server.h",
+        ],
+    deps = [
+        ":embedding_lib",
+		":instruction_lib",
+        ":model_lib",
+        ":utils_lib",
+    ],
+	visibility = [
+		"//visibility:public",
+	],
+)
+
+cc_test(
+  name = "server_lib_test",
+  size = "small",
+  srcs = ["server_test.cc"],
+  deps = [
+      "@gtest//:gtest_main",
+	  ":server_lib",
+      ":embedding_lib",
+      ],
+)
+
 cc_library(
     name = "utils_lib",
     srcs = [
diff --git a/Thread-1/lib/embedding.cc b/Thread-1/lib/embedding.cc
index 966a76d..892c77c 100644
--- a/Thread-1/lib/embedding.cc
+++ b/Thread-1/lib/embedding.cc
@@ -1,7 +1,9 @@
+
 #include <fstream>
 #include <iostream>
 #include <sstream>
 #include <cmath>
+#include <mutex>
 
 #include "utils.h"
 #include "embedding.h"
@@ -23,11 +25,22 @@ Embedding::Embedding(int length, double* data) {
 }
 
 Embedding::Embedding(Embedding* origin) {
+    std::lock_guard<std::mutex> lock(origin->mux);
 	int length = origin->get_length();
     embbedingAssert(length > 0, "Non-positive length encountered!", NON_POSITIVE_LEN);
     double* oldData = origin->get_data();
     double* newData = new double[length];
-    for(int i = 0; i<length; i++)newData[i] = oldData[i];
+    for(int i = 0; i<length; i++) newData[i] = oldData[i];
+    this->length = length;
+    this->data = newData;
+}
+
+Embedding::Embedding(Embedding const& origin) {
+	int length = origin.length;
+    embbedingAssert(length > 0, "Non-positive length encountered!", NON_POSITIVE_LEN);
+    double* oldData = origin.data;
+    double* newData = new double[length];
+    for(int i = 0; i<length; i++) newData[i] = oldData[i];
     this->length = length;
     this->data = newData;
 }
@@ -58,6 +71,8 @@ void Embedding::update(Embedding* gradient, double stepsize) {
 }
 
 std::string Embedding::to_string() {
+    std::lock_guard<std::mutex> lock(this->mux);
+
     std::string res;
     for (int i = 0; i < this->length; ++i) {
         if (i > 0) res += ',';
@@ -71,7 +86,7 @@ void Embedding::write_to_stdout() {
     std::cout << prefix << this->to_string() << '\n';
 }
 
-Embedding Embedding::operator+(const Embedding &another) {
+Embedding Embedding::operator+(Embedding &another) {
     double* data = new double[this->length];
     for (int i = 0; i < this->length; ++i) {
         data[i] = this->data[i] + another.data[i];
@@ -87,7 +102,7 @@ Embedding Embedding::operator+(const double value) {
     return Embedding(this->length, data);
 }
 
-Embedding Embedding::operator-(const Embedding &another) {
+Embedding Embedding::operator-(Embedding &another) {
     double* data = new double[this->length];
     for (int i = 0; i < this->length; ++i) {
         data[i] = this->data[i] - another.data[i];
@@ -103,7 +118,7 @@ Embedding Embedding::operator-(const double value) {
     return Embedding(this->length, data);
 }
 
-Embedding Embedding::operator*(const Embedding &another) {
+Embedding Embedding::operator*(Embedding &another) {
     double* data = new double[this->length];
     for (int i = 0; i < this->length; ++i) {
         data[i] = this->data[i] * another.data[i];
@@ -119,7 +134,7 @@ Embedding Embedding::operator*(const double value) {
     return Embedding(this->length, data);
 }
 
-Embedding Embedding::operator/(const Embedding &another) {
+Embedding Embedding::operator/(Embedding &another) {
     double* data = new double[this->length];
     for (int i = 0; i < this->length; ++i) {
         data[i] = this->data[i] / another.data[i];
@@ -135,7 +150,7 @@ Embedding Embedding::operator/(const double value) {
     return Embedding(this->length, data);
 }
 
-bool Embedding::operator==(const Embedding &another) {
+bool Embedding::operator==(Embedding &another) {
     for (int i = 0; i < this->length; ++i) {
         if(fabs(this->data[i]-another.data[i])>1.0e-6)return false;
     }
@@ -174,20 +189,26 @@ EmbeddingMatrix EmbeddingHolder::read(std::string filename) {
 }
 
 int EmbeddingHolder::append(Embedding* data) {
+    std::lock_guard<std::mutex> lock(this->mux);
+
     int indx = this->emb_matx.size();
     embbedingAssert(
-        data->get_length() == this->emb_matx[0]->get_length(),
+        indx == 0 | data->get_length() == this->emb_matx[0]->get_length(),
         "Embedding to append has a different length!", LEN_MISMATCH
     );
     this->emb_matx.push_back(data);
+
+    this->cv.notify_all();
     return indx;
 }
 
 void EmbeddingHolder::write(std::string filename) {
+    std::lock_guard<std::mutex> lock(this->mux);
+
     std::ofstream ofs(filename);
     if (ofs.is_open()) {
         for (Embedding* emb: this->emb_matx) {
-            ofs << emb->to_string() << '\n';
+            ofs << emb->to_string() + '\n';
         }
         ofs.close();
     } else {
@@ -196,9 +217,11 @@ void EmbeddingHolder::write(std::string filename) {
 }
 
 void EmbeddingHolder::write_to_stdout() {
+    std::lock_guard<std::mutex> lock(this->mux);
+
     std::string prefix("[OUTPUT]");
     for (Embedding* emb: this->emb_matx) {
-        std::cout << prefix << emb->to_string() << '\n';
+        std::cout << prefix + emb->to_string() + '\n';
     }
 }
 
@@ -208,16 +231,45 @@ EmbeddingHolder::~EmbeddingHolder() {
     }
 }
 
-void EmbeddingHolder::update_embedding(
-        int idx, EmbeddingGradient* gradient, double stepsize) {
-    this->emb_matx[idx]->update(gradient, stepsize);
+void EmbeddingHolder::update_embedding(int idx, EmbeddingGradient* gradient, double stepsize) {
+    Embedding* emb = this->get_embedding(idx);
+    emb->lock();
+    emb->update(gradient, stepsize);
+    emb->unlock();
 }
 
-bool EmbeddingHolder::operator==(const EmbeddingHolder &another) {
-    if (this->get_n_embeddings() != another.emb_matx.size())
+Embedding* EmbeddingHolder::get_embedding(int idx) {
+    std::unique_lock<std::mutex> lock(this->mux);
+
+    while (idx >= this->emb_matx.size()) {
+        this->cv.wait(lock);
+    }
+    return this->emb_matx[idx];
+}
+
+unsigned int EmbeddingHolder::get_n_embeddings() {
+    std::lock_guard<std::mutex> lock(this->mux);
+
+    return this->emb_matx.size();
+}
+
+int EmbeddingHolder::get_emb_length() {
+    std::lock_guard<std::mutex> lock(this->mux);
+
+    return this->emb_matx.empty()? 0: this->emb_matx[0]->get_length();
+}
+
+bool EmbeddingHolder::operator==(EmbeddingHolder &another) {
+    std::lock_guard<std::mutex> lock(this->mux);
+    std::lock_guard<std::mutex> lock1(another.mux);
+
+    if (this->emb_matx.size() != another.emb_matx.size())
         return false;
+
     for (int i = 0; i < (int)this->emb_matx.size(); ++i) {
-        if(!(*(this->emb_matx[i]) == *(another.get_embedding(i)))){
+        std::lock_guard<std::mutex> lock2(this->emb_matx[i]->mux);
+        std::lock_guard<std::mutex> lock3(another.emb_matx[i]->mux);
+        if(!(*(this->emb_matx[i]) == *(another.emb_matx[i]))){
         	return false;
 		}
     }
diff --git a/Thread-1/lib/embedding.h b/Thread-1/lib/embedding.h
index 6e13d14..0be6f15 100644
--- a/Thread-1/lib/embedding.h
+++ b/Thread-1/lib/embedding.h
@@ -1,8 +1,16 @@
 #ifndef THREAD_LIB_EMBEDDING_H_
 #define THREAD_LIB_EMBEDDING_H_
 
+// Embedding:
+// Constructor and output method get lock automatically
+// get data, operaters will not get lock
+
+// EmbeddingHolder: all methods are safe
+
 #include <string>
 #include <vector>
+#include <mutex>
+#include <condition_variable>
 
 namespace proj1 {
 
@@ -18,6 +26,7 @@ public:
     Embedding(int, double*);
     Embedding(int, std::string);
     Embedding(Embedding*);
+    Embedding(Embedding const&);
     ~Embedding() { delete []this->data; }
     double* get_data() { return this->data; }
     int get_length() { return this->length; }
@@ -25,15 +34,20 @@ public:
     std::string to_string();
     void write_to_stdout();
     // Operators
-    Embedding operator+(const Embedding&);
+    Embedding operator+(Embedding&);
     Embedding operator+(const double);
-    Embedding operator-(const Embedding&);
+    Embedding operator-(Embedding&);
     Embedding operator-(const double);
-    Embedding operator*(const Embedding&);
+    Embedding operator*(Embedding&);
     Embedding operator*(const double);
-    Embedding operator/(const Embedding&);
+    Embedding operator/(Embedding&);
     Embedding operator/(const double);
-    bool operator==(const Embedding&);
+    bool operator==(Embedding&);
+    //lock&unlock
+    std::mutex mux;
+    void lock() {this->mux.lock();}
+    void unlock() {this->mux.unlock();}
+
 private:
     int length;
     double* data;
@@ -52,14 +66,18 @@ public:
     void write(std::string filename);
     int append(Embedding *data);
     void update_embedding(int, EmbeddingGradient*, double);
-    Embedding* get_embedding(int idx) const { return this->emb_matx[idx]; } 
-    unsigned int get_n_embeddings() { return this->emb_matx.size(); }
-    int get_emb_length() {
-        return this->emb_matx.empty()? 0: this->get_embedding(0)->get_length();
-    }
-    bool operator==(const EmbeddingHolder&);
+    Embedding* get_embedding(int idx);
+    unsigned int get_n_embeddings();
+    int get_emb_length();
+    bool operator==(EmbeddingHolder&);
+
 private:
     EmbeddingMatrix emb_matx;
+    // lock&unlock
+    std::mutex mux;
+    // void lock() {this->mux.lock();}
+    // void unlock() {this->mux.unlock();}
+    std::condition_variable cv;
 };
 
 } // namespace proj1
diff --git a/Thread-1/lib/server.cc b/Thread-1/lib/server.cc
new file mode 100644
index 0000000..3cb4c74
--- /dev/null
+++ b/Thread-1/lib/server.cc
@@ -0,0 +1,281 @@
+
+#include <vector>
+#include <thread>
+#include <iostream>
+#include <mutex>
+
+#include "server.h"
+#include "model.h"
+#include "utils.h"
+
+#define TIMER(s) // proj1::AutoTimer timer(s)
+
+namespace proj1 {
+
+void Server::write_to_stdout() {
+    users.write_to_stdout();
+    items.write_to_stdout();
+}
+
+void Server::do_instruction(Instruction inst) {
+    switch(inst.order) {
+        case INIT_EMB: {
+            if (!useLock) {
+                do_init(inst);
+            } else if (!initParall) {
+                do_init_safe(inst);
+            } else {
+                do_init_parall(inst);
+            }
+            break;
+        }
+        case UPDATE_EMB: {
+            if (!useLock) {
+                do_update(inst);
+            } else if (!useEpoch) {
+                do_update_safe(inst);
+            } else {
+                do_update_epoch(inst);
+            }
+            break;
+        }
+        case RECOMMEND: {
+            if (!useLock) {
+                Embedding* emb = do_recommend(inst);
+                emb->write_to_stdout();
+            } else if (!useEpoch) {
+                Embedding* emb = do_recommend_safe(inst);
+                emb->write_to_stdout();
+            } else {
+                Embedding* emb = do_recommend_epoch(inst);
+                emb->write_to_stdout();
+            }
+        }
+    }
+}
+
+void Server::do_init(Instruction inst) {
+    TIMER("do_init");
+
+    int length = users.get_emb_length();
+    Embedding* new_user = new Embedding(length);
+    int user_idx = users.append(new_user);
+
+    for (int item_index: inst.payloads) {
+        Embedding* item_emb = items.get_embedding(item_index);
+
+        EmbeddingGradient* gradient = cold_start(new_user, item_emb);
+        users.update_embedding(user_idx, gradient, 0.01);
+        delete gradient;
+    }
+}
+
+void Server::do_init_safe(Instruction inst) {
+    TIMER("do_init_safe");
+
+    int length = users.get_emb_length();
+    Embedding* new_user = new Embedding(length);
+    int user_idx = users.append(new_user);
+
+    for (int item_index: inst.payloads) {
+        Embedding* item_emb = items.get_embedding(item_index);
+
+        Embedding* user = new Embedding(new_user);
+        Embedding* item = new Embedding(item_emb);
+        EmbeddingGradient* gradient = cold_start(user, item);
+        delete user, item;
+
+        users.update_embedding(user_idx, gradient, 0.01);
+        delete gradient;
+    }
+}
+
+void Server::do_init_parall(Instruction inst) {
+    TIMER("do_init_parall");
+
+    int length = users.get_emb_length();
+    Embedding* new_user = new Embedding(length);
+    int user_idx = users.append(new_user);
+
+    std::vector<std::thread*> threads;
+    for (int item_index: inst.payloads) {
+        std::thread* t = new std::thread(
+            [&, item_index]() {
+                Embedding* item_emb = items.get_embedding(item_index);
+
+                Embedding* user = new Embedding(new_user);
+                Embedding* item = new Embedding(item_emb);
+                EmbeddingGradient* gradient = cold_start(user, item);
+                delete user, item;
+
+                users.update_embedding(user_idx, gradient, 0.01);
+                delete gradient;
+            }
+        );
+        threads.push_back(t);
+    }
+    for (std::thread* t: threads) {
+        t->join();
+        delete t;
+    }
+}
+
+void Server::do_update(Instruction inst) {
+    TIMER("do_update");
+
+    std::cout << "do_update" << std::endl;
+    int user_idx = inst.payloads[0];
+    int item_idx = inst.payloads[1];
+    int label = inst.payloads[2];
+
+    Embedding* user_emb = users.get_embedding(user_idx);
+    Embedding* item_emb = items.get_embedding(item_idx);
+
+    EmbeddingGradient* gradient = calc_gradient(user_emb, item_emb, label);
+    users.update_embedding(user_idx, gradient, 0.01);
+    delete gradient;
+
+    gradient = calc_gradient(item_emb, user_emb, label);
+    items.update_embedding(item_idx, gradient, 0.001);
+    delete gradient;
+}
+
+void Server::do_update_safe(Instruction inst) {
+    TIMER("do_update_safe");
+
+    int user_idx = inst.payloads[0];
+    int item_idx = inst.payloads[1];
+    int label = inst.payloads[2];
+
+    Embedding* user_emb = users.get_embedding(user_idx);
+    Embedding* item_emb = items.get_embedding(item_idx);
+
+    auto user = new Embedding(user_emb);
+    auto item = new Embedding(item_emb);
+    EmbeddingGradient* gradient = calc_gradient(user, item, label);
+    delete user, item;
+
+    users.update_embedding(user_idx, gradient, 0.01);
+    delete gradient;
+
+    user = new Embedding(user_emb);
+    item = new Embedding(item_emb);
+    gradient = calc_gradient(item, user, label);
+    delete user, item;
+
+    items.update_embedding(item_idx, gradient, 0.001);
+    delete gradient;
+}
+
+void Server::do_update_epoch(Instruction inst) {
+    int iter_idx = inst.payloads[3];
+{
+    std::unique_lock<std::mutex> lock(this->mux);
+    while (!(this->epoch >= iter_idx || (this->epoch == iter_idx - 1 && this->num_threads == 0))) {
+        this->cv.wait(lock);
+    }
+    if (this->epoch == iter_idx - 1 && this->num_threads == 0) {
+        this->epoch = iter_idx;
+    }
+    this->num_threads++;
+}
+
+    TIMER("do_update_inst");
+
+    int user_idx = inst.payloads[0];
+    int item_idx = inst.payloads[1];
+    int label = inst.payloads[2];
+
+    Embedding* user_emb = users.get_embedding(user_idx);
+    Embedding* item_emb = items.get_embedding(item_idx);
+
+    auto user = new Embedding(user_emb);
+    auto item = new Embedding(item_emb);
+    EmbeddingGradient* gradient = calc_gradient(user, item, label);
+    delete user, item;
+
+    users.update_embedding(user_idx, gradient, 0.01);
+    delete gradient;
+
+    user = new Embedding(user_emb);
+    item = new Embedding(item_emb);
+    gradient = calc_gradient(item, user, label);
+    delete user, item;
+
+    items.update_embedding(item_idx, gradient, 0.001);
+    delete gradient;
+
+{
+    std::unique_lock<std::mutex> lock(this->mux);
+    this->num_threads--;
+    this->cv.notify_all();
+}
+}
+
+Embedding* Server::do_recommend(Instruction inst) {
+    TIMER("do_recommend");
+
+    int user_idx = inst.payloads[0];
+    Embedding* user = users.get_embedding(user_idx);
+
+    std::vector<Embedding*> item_pool;
+    for (unsigned int i = 2; i < inst.payloads.size(); i++) {
+        int item_idx = inst.payloads[i];
+        item_pool.push_back(items.get_embedding(item_idx));
+    }
+
+    Embedding* recommendation = recommend(user, item_pool);
+    return recommendation;
+}
+
+Embedding* Server::do_recommend_safe(Instruction inst) {
+    TIMER("do_recommend_safe");
+
+    int user_idx = inst.payloads[0];
+    Embedding* user = users.get_embedding(user_idx);
+    std::lock_guard<std::mutex> lock(user->mux);
+
+    std::vector<Embedding*> item_pool;
+    for (unsigned int i = 2; i < inst.payloads.size(); i++) {
+        int item_idx = inst.payloads[i];
+        Embedding* item = items.get_embedding(item_idx);
+        std::lock_guard<std::mutex> lock(item->mux);
+        item_pool.push_back(item);
+    }
+
+    Embedding* recommendation = recommend(user, item_pool);
+    return recommendation;
+}
+
+Embedding* Server::do_recommend_epoch(Instruction inst) {
+    int iter_idx = inst.payloads[1];
+{
+    std::unique_lock<std::mutex> lock(this->mux);
+    while (!(this->epoch > iter_idx | (this->epoch == iter_idx && this->num_threads == 0))) {
+        this->cv.wait(lock);
+    }
+}
+
+    TIMER("do_recommend_epoch");
+
+    int user_idx = inst.payloads[0];
+    Embedding* user = users.get_embedding(user_idx);
+    std::lock_guard<std::mutex> lock(user->mux);
+
+    std::vector<Embedding*> item_pool;
+    for (unsigned int i = 2; i < inst.payloads.size(); i++) {
+        int item_idx = inst.payloads[i];
+        Embedding* item = items.get_embedding(item_idx);
+        std::lock_guard<std::mutex> lock(item->mux);
+        item_pool.push_back(item);
+    }
+
+    Embedding* recommendation = recommend(user, item_pool);
+    return recommendation;
+}
+
+bool Server::operator==(Server& svr) {
+    return this->users == svr.users && this->items == svr.items;
+}
+
+} // namespace proj1
diff --git a/Thread-1/lib/server.h b/Thread-1/lib/server.h
new file mode 100644
index 0000000..c893a40
--- /dev/null
+++ b/Thread-1/lib/server.h
@@ -0,0 +1,48 @@
+#ifndef THREAD_LIB_SERVER_H_
+#define THREAD_LIB_SERVER_H_
+
+#include <mutex>
+#include <condition_variable>
+#include "instruction.h"
+#include "embedding.h"
+
+namespace proj1 {
+
+class Server {
+public:
+    Server(std::string user_filename, std::string item_filename) : users(user_filename), items(item_filename) {}
+    Server(std::string user_filename, std::string item_filename, bool initParall, bool useLock, bool useEpoch)
+        : users(user_filename), items(item_filename), initParall(initParall), useLock(useLock), useEpoch(useEpoch) {}
+    void do_instruction(Instruction);
+    void write_to_stdout();
+
+    void do_init(Instruction);
+    void do_init_safe(Instruction);
+    void do_init_parall(Instruction);
+
+    void do_update(Instruction);
+    void do_update_safe(Instruction);
+    void do_update_epoch(Instruction);
+
+    Embedding* do_recommend(Instruction);
+    Embedding* do_recommend_safe(Instruction);
+    Embedding* do_recommend_epoch(Instruction);
+
+    bool operator==(Server&);
+
+private:
+    bool initParall = false;
+    bool useLock = false;
+    bool useEpoch = false;
+
+    int epoch = -1;
+    int num_threads = 0; // number of update threads running in this epoch
+    std::mutex mux;
+    std::condition_variable cv;
+
+    EmbeddingHolder users;
+    EmbeddingHolder items;
+};
+
+} // namespace proj1
+#endif // THREAD_LIB_SERVER_H_
diff --git a/Thread-1/lib/server_test.cc b/Thread-1/lib/server_test.cc
new file mode 100644
index 0000000..036212b
--- /dev/null
+++ b/Thread-1/lib/server_test.cc
@@ -0,0 +1,53 @@
+#include <gtest/gtest.h>
+#include <vector>
+
+#include "server.h"
+#include "embedding.h"
+
+namespace proj1 {
+namespace testing {
+
+class ServerTest : public ::testing::Test {
+protected:
+    void SetUp() {
+        server1 = new Server("data/q4.in", "data/q4.in");
+        server2 = new Server("data/q4.in", "data/q4.in");
+        server3 = new Server("data/q4.in", "data/q4.in");
+
+        inst_init = new Instruction("0 0 1 2 3 4 5 6 7 8");
+        inst_update = new Instruction("1 7 5 0 0");
+        inst_recommend = new Instruction("2 2 -1 4 5 6 3 7 9");
+    }
+    Server *server1, *server2, *server3;
+    Instruction *inst_init, *inst_update, *inst_recommend;
+};
+
+TEST_F(ServerTest, test_init) {
+    server1->do_init(*inst_init);
+    server2->do_init_safe(*inst_init);
+    EXPECT_EQ((*server1) == (*server2), true);
+}
+
+TEST_F(ServerTest, test_update) {
+    server1->do_update(*inst_update);
+    server2->do_update_safe(*inst_update);
+    server3->do_update_epoch(*inst_update);
+    EXPECT_EQ((*server1) == (*server2), true);
+    EXPECT_EQ((*server2) == (*server3), true);
+}
+
+TEST_F(ServerTest, test_recommend) {
+    Embedding* emb1 = server1->do_recommend(*inst_recommend);
+    Embedding* emb2 = server2->do_recommend_safe(*inst_recommend);
+    Embedding* emb3 = server3->do_recommend_epoch(*inst_recommend);
+    EXPECT_EQ((*emb1) == (*emb2), true);
+    EXPECT_EQ((*emb2) == (*emb3), true);
+}
+    
+} // namespace testing
+} // namespace proj1
+
+int main(int argc, char** argv) {
+    testing::InitGoogleTest(&argc, argv);
+    return RUN_ALL_TESTS();
+}
diff --git a/Thread-1/lib/utils.cc b/Thread-1/lib/utils.cc
index 3427314..a440602 100644
--- a/Thread-1/lib/utils.cc
+++ b/Thread-1/lib/utils.cc
@@ -8,7 +8,9 @@
 namespace proj1 {
 
 void a_slow_function(int seconds) {
-    //std::this_thread::sleep_for(std::chrono::seconds(seconds));
+    if (slow_function) {
+        std::this_thread::sleep_for(std::chrono::timescale(seconds));
+    }
 }
 
 double sigmoid(double x) {
@@ -39,7 +41,7 @@ AutoTimer::AutoTimer(std::string name) :
 AutoTimer::~AutoTimer() {
     auto end = std::chrono::high_resolution_clock::now();
     auto dur = std::chrono::duration_cast<std::chrono::microseconds>(end - m_beg);
-    std::cout << m_name << " : " << dur.count() << " usec\n";
+    std::cout << m_name + " : " + std::to_string(dur.count()) + " usec\n";
 }
 
 } // namespace proj1
diff --git a/Thread-1/lib/utils.h b/Thread-1/lib/utils.h
index 9f85001..398acbe 100644
--- a/Thread-1/lib/utils.h
+++ b/Thread-1/lib/utils.h
@@ -6,6 +6,10 @@
 #include <iostream>
 #include <chrono>  // for AutoTimer function
 
+// slow_function
+#define slow_function true
+#define timescale seconds
+
 // For colored outputs in terminal
 #define RST  "\x1B[0m"
 #define KRED  "\x1B[31m"
diff --git a/Thread-1/q0_my.cc b/Thread-1/q0_my.cc
new file mode 100644
index 0000000..f7f992a
--- /dev/null
+++ b/Thread-1/q0_my.cc
@@ -0,0 +1,29 @@
+#include <vector>
+#include <tuple>
+
+#include <string>   // string
+#include <chrono>   // timer
+
+#include "lib/utils.h"
+#include "lib/server.h"
+#include "lib/instruction.h"
+
+int main(int argc, char *argv[]) {
+
+    proj1::Server server("data/q0.in", "data/q0.in");
+
+    proj1::Instructions instructions = proj1::read_instructrions("data/q0_instruction.tsv");
+
+    {
+        proj1::AutoTimer timer("q0");  // using this to print out timing of the block
+        // Run all the instructions
+        for (proj1::Instruction inst: instructions) {
+            server.do_instruction(inst);
+        }
+    }
+
+    // Write the result
+    server.write_to_stdout();
+
+    return 0;
+}
diff --git a/Thread-1/q1.cc b/Thread-1/q1.cc
index 974ad23..395470a 100644
--- a/Thread-1/q1.cc
+++ b/Thread-1/q1.cc
@@ -1,5 +1,39 @@
-#include <iostream> // cout, endl
+#include <vector>
+#include <tuple>
+
+#include <string>   // string
+#include <chrono>   // timer
+#include <thread>
+#include <vector>
+
+#include "lib/utils.h"
+#include "lib/server.h"
+#include "lib/instruction.h"
+
 int main(int argc, char *argv[]) {
-    std::cout << "please implement this function\n";
-    exit(1);
-}
\ No newline at end of file
+
+    proj1::Server server("data/q1.in", "data/q1.in", false, true, false);
+
+    proj1::Instructions instructions = proj1::read_instructrions("data/q1_instruction.tsv");
+
+    {
+        proj1::AutoTimer timer("q1");  // using this to print out timing of the block
+        // Run all the instructions
+
+        std::vector<std::thread*> threads;
+
+        for (proj1::Instruction inst: instructions) {
+            auto t = new std::thread([&server, inst](){server.do_instruction(inst);});
+            threads.push_back(t);
+        }
+        for (auto t: threads) {
+            t->join();
+            delete t;
+        }
+    }
+
+    // Write the result
+    server.write_to_stdout();
+
+    return 0;
+}
diff --git a/Thread-1/q2.cc b/Thread-1/q2.cc
index c4b7413..bdc561f 100644
--- a/Thread-1/q2.cc
+++ b/Thread-1/q2.cc
@@ -1,4 +1,39 @@
-#include <iostream> // cout, endl
+#include <vector>
+#include <tuple>
+
+#include <string>   // string
+#include <chrono>   // timer
+#include <thread>
+#include <vector>
+
+#include "lib/utils.h"
+#include "lib/server.h"
+#include "lib/instruction.h"
+
 int main(int argc, char *argv[]) {
-    exit(1);
-}
\ No newline at end of file
+
+    proj1::Server server("data/q2.in", "data/q2.in", true, true, false);
+
+    proj1::Instructions instructions = proj1::read_instructrions("data/q2_instruction.tsv");
+
+    {
+        proj1::AutoTimer timer("q2");  // using this to print out timing of the block
+        // Run all the instructions
+        
+        std::vector<std::thread*> threads;
+
+        for (proj1::Instruction inst: instructions) {
+            auto t = new std::thread([&server, inst](){server.do_instruction(inst);});
+            threads.push_back(t);
+        }
+        for (auto t: threads) {
+            t->join();
+            delete t;
+        }
+    }
+
+    // Write the result
+    server.write_to_stdout();
+
+    return 0;
+}
diff --git a/Thread-1/q3.cc b/Thread-1/q3.cc
index c4b7413..9a22363 100644
--- a/Thread-1/q3.cc
+++ b/Thread-1/q3.cc
@@ -1,4 +1,39 @@
-#include <iostream> // cout, endl
+#include <vector>
+#include <tuple>
+
+#include <string>   // string
+#include <chrono>   // timer
+#include <thread>
+#include <vector>
+
+#include "lib/utils.h"
+#include "lib/server.h"
+#include "lib/instruction.h"
+
 int main(int argc, char *argv[]) {
-    exit(1);
-}
\ No newline at end of file
+
+    proj1::Server server("data/q3.in", "data/q3.in", true, true, true);
+
+    proj1::Instructions instructions = proj1::read_instructrions("data/q3_instruction.tsv");
+
+    {
+        proj1::AutoTimer timer("q3");  // using this to print out timing of the block
+        // Run all the instructions
+        
+        std::vector<std::thread*> threads;
+
+        for (proj1::Instruction inst: instructions) {
+            auto t = new std::thread([&server, inst](){server.do_instruction(inst);});
+            threads.push_back(t);
+        }
+        for (auto t: threads) {
+            t->join();
+            delete t;
+        }
+    }
+
+    // Write the result
+    server.write_to_stdout();
+
+    return 0;
+}
diff --git a/Thread-1/q4.cc b/Thread-1/q4.cc
new file mode 100644
index 0000000..ab2ac15
--- /dev/null
+++ b/Thread-1/q4.cc
@@ -0,0 +1,36 @@
+#include <vector>
+#include <tuple>
+
+#include <string>   // string
+#include <chrono>   // timer
+#include <thread>
+#include <vector>
+
+#include "lib/utils.h"
+#include "lib/server.h"
+#include "lib/instruction.h"
+
+int main(int argc, char *argv[]) {
+
+    proj1::Server server("data/q4.in", "data/q4.in", true, true, true);
+
+    proj1::Instructions instructions = proj1::read_instructrions("data/q4_instruction.tsv");
+
+    {
+        proj1::AutoTimer timer("q4");  // using this to print out timing of the block
+        // Run all the instructions
+        
+        std::vector<std::thread*> threads;
+
+        for (proj1::Instruction inst: instructions) {
+            auto t = new std::thread([&server, inst](){server.do_instruction(inst);});
+            threads.push_back(t);
+        }
+        for (auto t: threads) {
+            t->join();
+            delete t;
+        }
+    }
+
+    return 0;
+}
